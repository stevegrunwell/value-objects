<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>The Beauty of PHP Value Objects</title>
    <meta property="og:title" content="The Beauty of PHP Value Objects" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://stevegrunwell.github.io/value-objects//featured-slide.jpg" />
    <meta property="og:url" content="https://stevegrunwell.github.io/value-objects/" />
    <link rel="shortcut icon" href="./favicon.ico" />
    <link rel="stylesheet" href="./dist/reset.css" />
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/white.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/a11y-dark.css" />

    <link rel="stylesheet" href=".//resources/styles.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template"><!-- .slide: class="title-slide" data-hide-footer -->
# The Beauty of PHP Value Objects

Steve Grunwell <!-- .element: class="byline" -->
[@stevegrunwell@phpc.social](https://phpc.social/@stevegrunwell)
[stevegrunwell.com/slides/value-objects](https://stevegrunwell.com/slides/value-objects)
</script></section><section ><section data-markdown><script type="text/template">
## What is a Value Object?

An <u>immutable object</u> that<br>is <u>always in a valid state</u> and<br><u>encapsulates domain data</u>.

<aside class="notes"><p>(In the broadest terms)</p>
<p>If you take nothing else away from this talk, remember:</p>
<ol>
<li>Value objects are immutable (meaning they cannot change)</li>
<li>Value objects are always in a valid state</li>
</ol>
</aside></script></section><section data-markdown><script type="text/template">
### A simple example: Age

```php
(new Age(37))->getValue();
#=> int(37)
```

```php
new Age(-1);
#=> Uncaught DomainException
```
<!-- .element: class="fragment" -->

<aside class="notes"><p>For a super-simple example, let&#39;s imagine we have a want to represent an age; maybe we&#39;re not concerned with upper-bounds, but we know that someone&#39;s age must be greater than or equal to zero.</p>
<p>If we construct an Age object with an age like 37, we can retrieve the value and all is well. If we try to create an Age with value -1, however, the value object throws an exception because value objects are always in a valid state.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Think custom types, not models

* Primitive types: int, float, bool, string,<br>null, array, object, resource
* <!-- .element: class="fragment" --> Value objects serve a similar purpose
    ```php
    new UnsignedInt(123);
    new NonEmptyString('hello, there!');
    ```

<aside class="notes"><p>PHP has a number of primitive types, which are built into the language.</p>
<p>Think of value objects as creating your own primitive types for your domain: if we wanted a type to represent unsigned integers, for example, we might define an UnsignedInt value object class, which would throw an exception if given anything but a positive integer value. Or a <code>NonEmptyString()</code> value object class, which requires the value not only be a string but non-empty, too.</p>
<p>Remember that a value object models data, but is <strong>not</strong> a model/entity! Instead, think of value objects as custom types that you can add to represent the values of your models&#39; properties</p>
</aside></script></section><section data-markdown><script type="text/template">
### Value Objects Must Be Immutable

What is the value of `$var`?

```php
$var = 4;
$var += 6;
```

<p class="fragment">What is the value of <code>int(4)</code>?</p>

<aside class="notes"><p>As you may recall, one of the major rules is that a value object must be immutable.</p>
<p>Let&#39;s try a little thought exercise: var equals 4, then we add 6 to var. What is the new value of var?</p>
<p>This isn&#39;t a trick question, the value of $var is 10, right? But that&#39;s the value of the variable; did the integer 4 change?</p>
<p>No: 10 and 4 are two different values, in the same way that &quot;example.com&quot; and &quot;example.org&quot; are two different URLs. The values assigned to a model&#39;s <em>properties</em> might change, but the values themselves do not change.</p>
<p>It&#39;s a bit &quot;Ship of Theseus&quot;, but it demonstrates that a value object represents a <em>value</em>, not a fungible object.</p>
<p>By making our value objects immutable, we can also be sure that methods don&#39;t accidentally change values.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Value Objects Must Be Valid

!["You Wouldn't Download a Car" meme, but instead it reads "You wouldn't increment a true"](resources/increment-a-true.jpg)<!-- .element: style="border: 75px solid #000;" -->

<aside class="notes"><p>A value object is only useful if you can rely on it having valid domain data.</p>
<p>If you had a boolean value of 7 or an integer with value &quot;taco&quot;, would that make sense?</p>
<p>In the same way, our value objects must always be in a valid state, which means our application must not allow invalid value objects to be constructed. Instead, we&#39;ll throw exceptions when given invalid data (more in a minute).</p>
</aside></script></section><section data-markdown><script type="text/template">
### Value Objects in the Wild

* DateTimeImmutable (but not DateTime)
<!-- .element: class="fragment" -->
* DateTimeZone, DateTimePeriod
<!-- .element: class="fragment" -->
* SensitiveParameterValue
<!-- .element: class="fragment" -->

<aside class="notes"><p>One value object class you might be very familiar with is <code>DateTimeImmutable</code>, which is pre-defined by PHP and represents a date and time.</p>
<p>Note that the regular <code>DateTime</code> class cannot be considered a value object, because it&#39;s not immutable!</p>
<p>Similarly, PHP has the DateTimeZone and DateTimePeriod classes, which represent a time zone and period of time, respectively.</p>
<p>SensitiveParameterValue (added in PHP 8.2) - value object that wraps potentially sensitive data to keep it out of logs, debug statements, etc.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Value Objects & Enums

* <!-- .element: class="fragment" --> Both apply domain constraints to data
* <!-- .element: class="fragment" --> Enums have a finite, known list of valid values
* <!-- .element: class="fragment" --> Value objects are dynamic, but must be valid

<aside class="notes"><p>Both value objects and enums serve a similar purpose: applying domain constraints to data.</p>
<p>By definition, an enum has a finite, known list of possible values: countries, currency codes, user statuses, etc.</p>
<p>Value objects, on the other hand, must adhere to domain constraints but could have <em>any</em> number of values. For instance, the value of a Username object might be any any string that consists of at least 2 but no more than 30 letters, numbers, or underscores.</p>
<p>If an enum makes more sense for your domain, by all means use that instead of a value objectâ€”both are useful ways to represent domain data.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Value & Data Transfer Objects

* **DTOs:**
    * entity/model (or other structured data) <!-- .element: class="fragment" data-fragment-index="0" -->
    * no guarantee of validity <!-- .element: class="fragment" data-fragment-index="1" -->
* **Value Objects:**
    * single (possibly-complex) value <!-- .element: class="fragment" data-fragment-index="0" -->
    * must be valid <!-- .element: class="fragment" data-fragment-index="1" -->

<aside class="notes"><p>While they&#39;re related, please don&#39;t confuse Value Objects with Data Transfer Objects (DTOs).</p>
<p>DTOs are meant to provide a simplified representation of an entity or model; think how you might format the model to send it to the front end of your app. These are generally used in two places: when you&#39;re ingesting user requests and when you&#39;re sending data out of the application (front-end, APIs, etc.).</p>
<p>Value objects, on the other hand, represent a single value.</p>
<p>Additionally, DTOs enforce the shape of the data, but <strong>do not</strong> necessarily guarantee that data aheres to domain requirements (e.g. you might have an age less than zero)</p>
<p>However, there&#39;s nothing stopping you from including value objects in your DTOs as long as you ensure that they can be serialized properly (more on this in a moment).</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
## Building Value Objects

<aside class="notes"><p>Now that you understand that value objects are meant to represent actual values and must be both immutable and valid, let&#39;s discuss how we might build them in our own applications. But first, the elePHPant in the room...</p>
</aside></script></section><section data-markdown><script type="text/template">
### The Framework Dilema

_Should I use a framework for value objects?_

<aside class="notes"><p>This is subjective, but I would say no: value objects should be as close to pure PHP as possible, and should be specialized to your application&#39;s domain.</p>
<p>You might find it helpful to define interfaces for consistency or traits for common properties, but I&#39;d avoid frameworks and inheritance from any general-purpose value object class; if you need a complex inheritance scheme, you&#39;re probably overthinking things.</p>
<p>As we look at writing value objects, you&#39;ll see how simple they can be.</p>
</aside></script></section><section data-markdown><script type="text/template">
### A simple value object

```php [|7-11|3,13]
class Url
{
    private string $url;

    public function __construct(string $url)
    {
        if (!filter_var($url, FILTER_VALIDATE_URL)) {
            throw new \DomainException(
                sprintf('"%s" is not a valid URL!', $url)
            );
        }

        $this->url = $url;
    }
}
```
<!-- .element: class="hide-line-numbers growth-spurt" -->

<aside class="notes"><p>Here&#39;s one of the simplest value objects we can build: a URL</p>
<p>The constructor uses PHP&#39;s built-in <code>filter_var()</code> function with the <code>FILTER_VALIDATE_URL</code> filter;
if it doesn&#39;t validate against RFC 2396, we&#39;ll throw a <code>DomainException</code>.</p>
<p>If it validates, we save the value to <code>$this-&gt;url</code>.</p>
<p>At this point, we cannot construct a <code>Url</code> object with an invalid URL, so the <code>$url</code> property will always be a valid URL.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Retrieving values

```php
public function getValue(): string
{
    return $this->url;
}
```

<aside class="notes"><p>In order to access our value, we might add a method like <code>getValue()</code>. In it, we can simply return <code>$this-&gt;url</code> since we know that it&#39;s valid, and the value will be a string because that&#39;s the underlying primitive type.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Pro-tip: <span class="no-text-transform">__toString()</span>

```php
public function __toString(): string
{
    // This could also just be `return $this->url`.
    return $this->getValue();
}
```

```php
echo new Url('https://example.com');
#=> https://example.com
```
<!-- .element: class="fragment" -->

<aside class="notes"><p>To make value objects even easier to work with, consider defining a __toString() method.</p>
<p>Any time someone tries to treat the value as a string, you can control what they&#39;ll see.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Modern PHP, Better Value Objects

```php
class NonEmptyString
{
    public readonly string $value;

    // ...
}
```

```php
(new NonEmptyString('Put a bird on it!'))->value;
#=> string(17) "Put a bird on it!"
```
<!-- .element: class="fragment" -->

<aside class="notes"><p>If you&#39;re using modern versions of PHP, you can take advantage of some nice features:</p>
<p>Readonly properties (PHP 8.1+) for direct property access (instead of a <code>getValue()</code>) method while staying immutable</p>
<p>This could be emulated with magic __get() methods, but setters should not be defined</p>
<p>Similarly, property hooks (PHP 8.4+) can simplify the retrieval of values, but should not be used for setters; all values should be passed via the constructor, then the object should be immutable!</p>
</aside></script></section><section data-markdown><script type="text/template">
### Constructor Property Promotion

```php [|3|5-9]
class Age
{
    public function __construct(public readonly int $value)
    {
        if ($value < 0) {
            throw new \RangeException(
                'Ages cannot be less than 0'
            );
        }
    }
}
```
<!-- .element: class="hide-line-numbers growth-spurt" -->

<aside class="notes"><p>With constructor property promotion (was introduced in PHP 8.0), we can also do something like this to create a public, readonly (again, 8.1+) property named value.</p>
<p>Note that the constructor method still runs, so we can throw an exception if the value is an integer less than zero.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Complex Value Objects

```php [|5-8|9-13]
use App\Enums\Currency;

class Price
{
    public function __construct(
        public readonly int $amount,
        public readonly Currency $currency
    ) {
        if ($amount < 0) {
            throw new \DomainException(
                'Cannot have a negative price.'
            );
        }
    }
}
```
<!-- .element: class="hide-line-numbers growth-spurt" -->

<aside class="notes"><p>Be aware that value objects don&#39;t have to be limited to a single field; in fact, they become even more valuable when dealing with things like money.</p>
<p>In this case, we have a Price value object, which stores the amount (stored in the smallest denomination of the currency) and are using a Currency enum.</p>
<p>We get some validation for free by requiring the second argument be a valid Currency enum value, but we&#39;ll also make sure that a price is not less than 0.</p>
<p>Of course, if negative prices make sense for your domain, this validation rule might not apply. This is a good reminder that value objects are meant to be tailored to your domain.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Compound Value Objects

```php
class Address
{
    public function __construct(
        public readonly StreetAddress $street_address,
        public readonly ?StreetAddress $extended_address,
        public readonly Locality $locality,
        public readonly Region $region,
        public readonly PostalCode $postal_code,
        public readonly Country $country
    ) {
        // ...
    }
}
```

<aside class="notes"><p>Value objects may also be made up of other value objects, which can be really useful for things like addresses.</p>
<p>Here, we might have value objects defined for street addresses, localities/cities, regions/states, postal codes, and countries. We can then construct a full address that will always be valid.</p>
<p>Within our constructor, we also don&#39;t have to worry about validating any individual components, since we already know they&#39;re valid.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Testing

```php [|3-10|11-15]
final class UrlTest extends TestCase
{
    public function testConstructorValidatesUrls(): void
    {
        $this->assertSame(
            'https://example.com',
            (new Url('https://example.com'))->getValue()
        );
    }

    public function testConstructorThrowsIfInvalid(): void
    {
        $this->expectException(\DomainException::class);
        new Url('ðŸ’©');
    }
}
```
<!-- .element: class="hide-line-numbers growth-spurt" -->

<aside class="notes"><p>One of the really great things about value objects is that it makes unit testing super easy: we can test the value object, and then know that everywhere it&#39;s used will be valid!</p>
<p>On one slide, we&#39;re able to fit the most bare-bones test case (would use a data provider, personally).</p>
<p>First, we validate that a URL with value &quot;<a href="https://example.com&quot;">https://example.com&quot;</a> returns that same value when we call <code>getValue()</code></p>
<p>Then, we test that the constructor throws if given an invalid URL.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Let's see another example!

```php [|6-8|4]
class Email
{
    public function __construct(
        public readonly string $email
    ) {
        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            throw new \DomainException('Invalid email!');
        }
    }
}
```
<!-- .element: class="hide-line-numbers" -->

<aside class="notes"><p>It&#39;s very common to be handling email addresses in our applications, but they&#39;re usually passed around as strings.</p>
<p>This is one of my favorite use-cases for value objects: defining a simple Email type like this ensures that we&#39;re always working with a valid email address.</p>
<p>In this case, we accept an email address as a string, then use the <code>FILTER_VALIDATE_EMAIL</code> filter to ensure that the email address adheres to the email address specifications. If not, we throw a <code>DomainException</code>.</p>
<p>Notice that we were able to use the public, readonly $email property instead of a <code>getValue()</code> method.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Testing Email

```php
final class EmailTest extends TestCase
{
    public function testWithValidEmail(): void
    {
        $this->assertSame(
            'hello@example.com',
            new Email('hello@example.com')->email
        );
    }

    public function testWithInvalidEmail(): void
    {
        $this->expectException(\DomainException::class);
        new Email('example.com');
    }
}
```
<!-- .element: class="growth-spurt" -->

<aside class="notes"><p>Again, our value object is pretty trivial to test. We&#39;d probably want a few more test cases here, but we&#39;re able to verify that a valid email passes, and an invalid email fails.</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
## Using value objects

<aside class="notes"><p>We&#39;ve discussed how to build value objects, but let&#39;s see how they make things easier throughout our applications.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Typehinting

```php
public function sendMessage(
    Email $email,
    string $subject,
    string $body
) {
    // ...
}
```

```php
$this->sendMessage('example.com', /* ... */);
#=> Fatal error: Uncaught TypeError: SomeClass::sendMessage(): Argument #1 ($email) must be of type Email, string given...
```
<!-- .element: class="fragment" -->

<aside class="notes"><p>Perhaps the biggest benefit of value objects is that suddenly we can typehint them.</p>
<p>Imagine we have a <code>sendMessage()</code> method that sends an email; it has three arguments:</p>
<p>email, which must be an Email value object (and thus a valid email address), then subject and body, which both must be strings (though we could create value objects for these, too).</p>
<p>If anyone tries to pass a plain string instead of an Email value, they&#39;ll get a <code>TypeError</code>. If they try to construct the value with an invalid email address, they&#39;ll get a <code>DomainException</code>.</p>
<p>As long as we have an Email object, we know that it&#39;s valid!</p>
</aside></script></section><section data-markdown><script type="text/template">
### Property Typehints

```php
class User
{
    public Email $email;

    // ...
}
```

<aside class="notes"><p>We&#39;re not only type-hinting method arguments, either. Thanks to typed properties, we can ensure that this user class&#39; email property is always an instance of our Email value object class.</p>
<p>Then, because we know our Email value objects are always valid, we know that a user&#39;s email is valid, too!</p>
<p>Speaking of valid...</p>
</aside></script></section><section data-markdown><script type="text/template">
### Validation

```php
try {
    $username = new Username($request->input('username'));
} catch (\DomainException $e) {
    // This username doesn't fit our requirements
}

// Other validation
```

<aside class="notes"><p>Once we&#39;ve defined value objects, we can use them for tasks like validation: the value object should already know the rules (min/max length, characters, etc.), so we could take user input and see if it passes.</p>
<p>The benefit here is that your username validation logic is in one, easily-tested location. If the rules change, there&#39;s one place that needs to be updated.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Validation Helper

```php
class Username
{
    // ...

    public static function isValid(string $value): bool
    {
        try {
            new self($value);
        } catch (\DomainException $e) {
            return false;
        }

        return true;
    }
}
```
<!-- .element: class="growth-spurt" -->

<aside class="notes"><p>If you find yourself doing a lot of try/catch validation blocks, you might also consider something like a static <code>isValid()</code> helper method on your value object class; here, it attempts to construct an instance of itself with a given value and, if it catches a DomainException, return false.</p>
<p>Otherwise, if it constructed without issue, it returns true.</p>
<p>Note that this is a static method, because we can&#39;t have an invalid instance of our value object classes.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Comparing Value Objects

```php [1-2|4-5|7-8]
$rating1 = new AverageRating(4.0);
$rating2 = new AverageRating(4.0);

$rating1 == $rating2;
#=> bool(true);

$rating1 === $rating2;
#=> bool(false)
```
<!-- .element: class="hide-line-numbers" -->

<aside class="notes"><p>One drawback to value objects is that we need to be clever when comparing them, because each time we call the constructor we get a new instance of the object.</p>
<p>Given two instances of AverageRating with the same value of 4.00, they will evaluate as loosely equal but, because they are separate instances, will fail a strict equality check.</p>
<p>There are a few ways we can address this:</p>
</aside></script></section><section data-markdown><script type="text/template">
#### Comparator Methods

```php
public function isEqualTo(AverageRating $rating): bool
{
    return $rating->value === $this->value;
}
```

```php
$rating1->isEqualTo($rating2);
#=> bool(true)
```
<!-- .element: class="fragment" -->

<aside class="notes"><p>The first approach is to create methods like <code>isEqualTo()</code>, <code>isGreaterThan()</code>, etc. on the value object class. We typehint the argument as another instance of the value object, then compare the underlying values.</p>
<p>The methods you might define here will vary based on the types of comparisons that are necessary for your domain.</p>
</aside></script></section><section data-markdown><script type="text/template">
#### More Comparator Methods

```php
public function isSameBuilding(Address $address): bool
{
    return $this->street_address == $address->street_address
        && $this->region == $address->region
        && $this->locality == $address->locality
        && $this->postal_code == $address->postal_code;
}
```
<!-- .element: class="growth-spurt" -->

<aside class="notes"><p>If you&#39;re dealing with complex or compound value objects, you might also consider comparators that operate on multiple values.</p>
<p>In this instance, we might have an <code>isSameBuilding()</code> method that checks the key values but ignores things like apartment/suite number.</p>
<p>Maybe you&#39;re dealing with money and want to check that two amounts are in the same currency.</p>
<p>These are powerful methods that clean up your domain logic in a way that&#39;s both clear and easy to test.</p>
</aside></script></section><section data-markdown><script type="text/template">
#### Value comparisons

```php [1-2|4-5|7-8]
$rating1->value === $rating2->value;
#=> bool(true)

$rating1->checksum() === $rating2->checksum();
#=> bool(true)

(string) $rating1 === (string) $rating2;
#=> bool(true)
```
<!-- .element: class="hide-line-numbers" -->

<aside class="notes"><p>Another approach would be comparing the underlying values directly.</p>
<p>If you have multiple properties, you might consider something like a <code>checksum()</code> method, which creates a determinate value.</p>
<p>If you implemented a <code>__toString()</code> method, you could also compare them as strings.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Manipulation

```php [1-2|4-12]
$age1 = new Age(37);
$age2 = $age1->increment();

var_dump($age1, $age2)
#=> object(Age)#1 (1) {
#     ["value":"Age":private]=>
#     int(37)
#   }
#   object(Age)#2 (1) {
#     ["value":"Age":private]=>
#     int(38)
#   }
```
<!-- .element: class="hide-line-numbers" -->

<aside class="notes"><p>Remember that value objects need to be immutable, but that doesn&#39;t mean you can&#39;t manipulate values.</p>
<p>In this case, we&#39;ve defined an <code>Age</code> object with a value of 37. Now imagine we have an increment method: it <strong>must</strong> return a <em>new</em> <code>Age</code> instance, because value objects are immutable.</p>
<p>This is the same thing that happens when you try to manipulate a <code>DateTimeImmutable</code> object: the methods defined by <code>DateTimeInterface</code> are implemented, but the object returned is not the same instance on which you called them, since that object is immutable.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Serialization

```php
class Email implements \JsonSerializable
{
    // ...

    public function jsonSerialize(): string
    {
        return $this->value;
    }
}
```

```php
json_encode(new Email('test@example.com'));
#=> "test@example.com"
```
<!-- .element: class="fragment" -->

<aside class="notes"><p>There are two major ways that PHP can serialize objects:</p>
<ol>
<li>PHP serialization, which stores the properties of the object in an encoded string</li>
<li>JSON serialization, which tends to be faster and more interoperable with other systems, created via <code>json_encode()</code></li>
</ol>
<p>By default, PHP serialization tends to work well for value objects, since it&#39;s explicitly enumerating the object properties.</p>
<p>It can be helpful to implement the <code>JsonSerializable</code> interface in your value objects, which let you determine what happens when the value object is JSON-encoded (default is an empty object).</p>
<p>For simple value objects, this may just be the underlying, primitive value.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Serialization

```php
class Coordinates implements \JsonSerializable
{
    // ...

    public function jsonSerialize(): array
    {
        return [
            'lat' => $this->latitude,
            'lng' => $this->longitude,
        ];
    }
}
```

```php
json_encode(new Coordinates(41.9974, -87.8844));
#=> {"lat":41.9974,"lng":-87.8844}
```
<!-- .element: class="fragment" -->

<aside class="notes"><p>If you have a more complex value object, like coordinates, you might return an array representing relevant values.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Hydrating from database

```php [1|2-4,9|5-8]
$query = 'SELECT DISTINCT locality, region FROM addresses';
$dbh->query($query)
    ->fetchAll(
        PDO::FETCH_FUNC,
        fn ($locality, $region) => new CityState(
            new City($locality),
            new State($region)
        )
    );
```
<!-- .element: class="hide-line-numbers growth-spurt" -->

<aside class="notes"><p>If you&#39;re interacting with a database, automatically retrieving specific columns as value objects can be immensely helpful.</p>
<p>If you&#39;re using PDO directly, you might define a fetch function like this that automatically casts results to value objects.</p>
<p>In this case, we&#39;re constructing a CityState object, which is a compound value object that consists of City and State objects. The query will result in one CityState instance for each unique combination of locality and region (city and state) in our database.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Eloquent Casting

```sh
php artisan make:cast HexColor
```

```php
use App\Casts\HexColor;
use Illuminate\Database\Eloquent\Model;

class Profile extends Model
{
    protected function casts(): array
    {
        return [
            'background_color' => HexColor::class,
        ];
    }
}
```
<!-- .element: class="fragment" -->

<aside class="notes"><p>If you&#39;re using Laravel, Eloquent has a built-in way to cast model properties.</p>
<p>If you&#39;ve noticed that columns like created_at and updated_at come back as Carbon objects, this should be very familiar (same approach).</p>
<p>First, we need to generate a new implementation of the <code>Illuminate\Contracts\Database\Eloquent\CastsAttributes</code> interface, which we can do with this Artisan command.</p>
<p>It will generate a App\Casts\HexColor class that implements CastsAttributes, which has two methods:</p>
<ol>
<li><code>get()</code> will return a value object</li>
<li><code>set()</code> will extract the underlying value so that it may be stored in the database</li>
</ol>
<p>Then, in our model, add the property to the array returned from our <code>casts()</code> method, ensuring it references the CastsAttributes implementation. Now, any time we reference the background_color attribute on our model, we&#39;ll get a HexColor value object.</p>
<p>If you&#39;re using Doctrine, look at &quot;Custom Mapping Types&quot; and &quot;Embedables&quot;</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
## Adding Value to your<br>Value Objects

<aside class="notes"><p>I hope by now you have a solid grasp on value objects and how they&#39;re useful.</p>
<p>Let&#39;s wrap up by looking at ways to get even more out of your value objects.</p>
</aside></script></section><section data-markdown><script type="text/template">

### Specialized Getters

```php
class Url
{
    // ...

    public function getProtocol(): string
    {
        // "http", "https", etc.
    }

    public function getHost(): string
    {
        // "example.com", "example.org", etc.
    }
}
```

<aside class="notes"><p>Once we&#39;ve encapsulated the URL in a value object, we can also add methods to retrieve things like the protocol, host, path, and everything else that makes up a URL.</p>
<p>This means you won&#39;t have to litter your codebase with <code>parse_url()</code>, and it allows you to include logic like null coalescing, so <code>getQuery()</code> could return an empty string if no such value is set.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Pro-tip: Don't Repeat Yourself!

```php [3,10-13|5-8]
class Url
{
    private array $parsed;

    public function getQuery(): string
    {
        return $this->parse()['query'] ?? '';
    }

    private function function parse(): array
    {
        return $this->parsed ??= parse_url($this->url);
    }
}
```
<!-- .element: class="hide-line-numbers" -->

<aside class="notes"><p>When implementing these methods, we might call a <code>parse()</code> method that parses + caches parsed url, returning an array of its components.</p>
<p>This ensures that we&#39;re only calling <code>parse_url()</code> once, not every time we try to retrieve an element. Better yet, we don&#39;t have to actually call <code>parse_url()</code> at all until the first time we need to retrieve a component.</p>
<p>Please remember that just-in-time parsing methods like this should not be used for the actual validation of the data, as that should happen at the time the value object is instantiated!</p>
</aside></script></section><section data-markdown><script type="text/template">
### Testing Getters

```php
public function testGetHost(): void
{
    $this->assertSame(
        'example.com',
        (new Url('https://example.com'))->getHost()
    );
}
```

<aside class="notes"><p>If we&#39;ve added custom getters, we can easily test these, too!</p>
</aside></script></section><section data-markdown><script type="text/template">
### Factory Methods

```php [|8-12]
class Age
{
    // ...

    public static function fromBirthdate(
        \DateTimeInterface $bday
    ): self {
        $age = (new \DateTimeImmutable('now'))
            ->diff($bday)
            ->format('%Y');

        return new self((int) $age);
    }
}
```
<!-- .element: class="hide-line-numbers" -->

<aside class="notes"><p>Adding factory methods to your value objects can make it easier to construct them.</p>
<p>For instance, we could calculate someone&#39;s age by taking their birthday (as a datetime object) and comparing it to now. In this case, calculate the difference in years, then cast that as an integer and construct a new Age value object.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Objects, Not Arrays

```php
$request_body = [
    'name' => 'Taco',
    'type' => 'cat',
    'age'  => 3,
];
```

```php
new PetRequest(...$request_body);
```
<!-- .element: class="fragment" -->

```php
new PetRequest(
    name: $request_body['name'],
    type: $request_body['type'],
    age: $request_body['age']
);
```
<!-- .element: class="fragment" -->

<aside class="notes"><p>This doesn&#39;t strictly apply to value objects, but is worth mentioning:</p>
<p>Associative arrays have been abused for a long time in PHP; whether it&#39;s the body of a POST request or some sort of pseudo-struct, associative arrays offer no type-safety, no immutability, and are a common source of undefined array key warnings.</p>
<p>Imagine we have this $request_body, which has a few details about my cat in an associative array.</p>
<p>As of PHP 8.1, associative arrays may be unpacked into named arguments, so in one line we could turn this array into a <code>PetRequest</code> value object. Note that this would work in versions before 8.1 too, but the argument order would matter.</p>
<p>Now we have a valid, immutable object representing the request body!</p>
</aside></script></section></section><section  data-markdown><script type="text/template">
## Where Else Might You Use Value Objects?

![David S. Pumpkins (Tom Hanks) and his two skeleton B-Boys from Saturday Night Live, with the caption "Any questions?"](resources/david-s-pumpkins.jpg)
<!-- .element: class="fragment" -->

<aside class="notes"><p>I&#39;ve shown you a range of different applications for value objects, but I&#39;m sure new ones have popped into your heads.</p>
<p>Where else might you find value objects useful?</p>
<p>As you&#39;ve seen, value objects can be a beautiful way to encapsulate your domain logic into easily-maintained, easily-tested chunks.</p>
<p>REMEMBER TO REPEAT THE QUESTION!!</p>
</aside></script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-hide-footer -->

## Thank You!

Steve Grunwell<br>
<span style="font-size: .75em;">Staff Software Engineer, Mailchimp</span>

[stevegrunwell.com/slides/value-objects](https://stevegrunwell.com/slides/value-objects)<!-- .element: class="slides-link" -->
</script></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        slideNumber: true,
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"controls":true,"controlsTutorial":false,"pause":true,"pdfSeparateFragments":false,"progress":false,"slideNumber":false,"transition":"none"}, queryOptions);
    </script>

    <script src=".//resources/scripts.js"></script>

    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
